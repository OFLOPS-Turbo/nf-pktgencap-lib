//vi:syntax=c
/**
 *      @file  nf_pktgen.h
 *     @brief  Header file for the NetFPGA traffic generator control library.
 *
 * This library allows users to control through C the traffic generation and capturing functionality
 * for the equivalent bitfiles for the NetFPGA platform.
 *
 *    @author  Charalampos Rotsos <cr409@cl.cam.ac.uk>
 *
 *  @internal
 *    Created  16*06*14
 *   Revision  $Id: doxygen.cpp.templates,v 1.3 2010*07*06 09:20:12 mehner Exp $
 *   Compiler  gcc*g++
 *    Company  Computer Laboratory, University of Cambridge
 *
 * This source code is released for free distribution under the terms of the
 * GNU General Public License as published by the Free Software Foundation.
 *=====================================================================================
 */

#ifndef NF_PKTGEN_H_
#define NF_PKTGEN_H_ 1

#include <pcap.h>
#include <stdint.h>

/**
 * A struct containing statistics regarding the traffic
 * generation functionality per port.
 */
struct nf_cap_stats {
    uint32_t byte_cnt;   ///< Port counter of generated bytes.
    uint32_t pkt_cnt;    ///< Port counter of generated packets.
    uint32_t capture_packet_cnt;
};

/**
 * A struct storing information regarding per port traffic capturing.
 */
struct nf_gen_stats {
    uint32_t pkt_snd_cnt; ///< Port counter of captured packets.
};

#ifndef PKTGEN_HDR
#define PKTGEN_HDR 1
/**
 * A header appended in each generated packet, containing packet
 * statistics.
 */
struct pktgen_hdr {
    uint32_t magic;     ///< Constant 32-bit string allowing the identification
					    ///   of the header start.
    uint32_t seq_num;   ///< A monotonically increasing packet sequence counter.
    uint32_t tv_sec;    ///< The seconds timestamp of the packet generation.
    uint32_t tv_usec;   ///< The nanoseconds timestamp of the packet generation.
};
#endif

struct nf_cap_t;

/**
 * @breif Initialisation of the traffic generator and capturer.
 * @param pad use packet compression (1G NetFPGA only)
 * @param nodrop control the behaviour of the capturer when packet buffers are full (1G NetFPGA only)
 * @param resolve_ns PCAP header precision (1G NetFPGA only)
 */
int nf_init(int pad, int nodrop, int resolve_ns);

/** \defgroup nf_gen_data_ctrl Traffic generation data control.
  * @{ */
/**
 *  @brief Use a PCAP trace to generate traffic.
 *  @param filename The path of the PCAP trace.
 *  @param delay Nanosecond constant inter-packet delay.
 *  returns -1 in case of error, otherwise 0.
 */
int nf_gen_load_pcap(const char *filename, int port, uint64_t delay);
/**
 *  @brief Append a new packet to transmit on a specific port.
 *  @param h Packet size informations.
 *  @param data Packet data.
 *  @param port The number of the port to transmit the packet.
 *  @param delay Nanosecond delay before transmission.
 *  returns -1 in case of error, otherwise 0.
 */
int nf_gen_load_packet(struct pcap_pkthdr *h, const unsigned char *data,
                       int port, uint64_t delay);
/**
 *  @brief Remove all packets scheduled to transmit on a specific card port.
 *  @param port The device port.
 */
int nf_gen_reset_queue(int port);

/**
 * @brief Define the number of repetitions for the transmission of the loaded traces.
 * @param number_iterations The number of iterations.
 * @param iterations_enable Is the trace going to repeat transmission.
 * @param queue Define the port on which we control the repetitions.
 */
int nf_gen_set_number_iterations(int number_iterations, int iterations_enable,
                                 int queue);

int nf_gen_rate_limiter_enable(int port, int cpu);
int nf_gen_rate_limiter_disable(int port, int cpu);
int nf_gen_rate_limiter_set(int port, int cpu, float rate);


/** @} */

/**
 * @brief   A function to start the traffic generation and capture of data, once the
            session is initialised.
 * @param wait Controls if the function will block until completion of the traffic generation.
 * @return 0 if something was wrong, otherwise 1.
 */
int nf_start(int wait);
int nf_finish();
/**
 * @brief wait until traffic generation is completed.
 * @return 0 if everything went well, otherwise -1
 */
int nf_gen_wait_end();
/**
 * @brief check if traffic generation has completed.
 * @return 1 on completion, otherwise 0.
 */
int nf_gen_finished();
/**
 * @brief rerun the traffic generation task.
 * @return -1 on error, otherwise 0.
 */
int nf_restart();

/** \defgroup nf_cap_data_ctrl Traffic capture control.
  * @{ */
/**
 * @brief enable traffic capturing on a specific. This is a software layer filter at this point.
 * @param dev_name the device name.
 * @param caplen number of btes captured from each packet.
 * @return NULL on error, otherwise an nf_cap_t structure.
 */
struct nf_cap_t *nf_cap_enable(char *dev_name, int caplen);
/**
 * @brief Get a pollable file descriptor for captured packets on a specific device.
 * @param cap a capture session, reurned from nf_cap_enable.
 * @return -1 on error, otherwise a non negative int file descriptor.
 */
int  nf_cap_fileno(struct nf_cap_t *cap);

/**
 * @brief   get a new captured packet from a specific port. The call blocks until a packet is available.
 * @param cap a captring session, initialized using the nf_cap_enable function.
 * @param h a pointer to a pcap_header struct to copy the header information of the packet.
 * @return NULL on error, otherwise tha packet data.
 * @return
 */
const uint8_t *nf_cap_next(struct nf_cap_t *cap, struct pcap_pkthdr *h);
/** @} */

/** \defgroup nf_stats Session statistics.
  * @{ */

/**
 * @brief   fetching traffic generation statistics for a specific port.
 * @param   queue Port id.
 * @param   stat A memory location to write the statics.
 * @return  -1 on error, otherwise 0.
 */
int nf_gen_stat(int queue, struct nf_gen_stats *stat);

/**
 * @brief   fetch traffic capture statistics for a specific port.
 * @param   queue Port id.
 * @param   stat A memory location to write the statics.
 * @return  -1 on error, otherwise 0.
 */
int nf_cap_stat(int queue, struct nf_cap_stats *stat);
/** @} */

/** \defgroup nf_util Various utility function to ease development.
* @{ */

/**
 * @brief   get the time of the internal time counter of the NetFPGA card.
 * @param   ts A memory location to store the time in struct timeval format.
 */
void  nf_cap_timeofday(struct timeval *now);

/**
 * @brief   Extract the packet header append by the hardware desing during the transmission of a packet.
 * @param   A capture session initialized by the nf_cap_enable function.
 * @param   The packet data.
 * @param   The packet length.
 * @return  Return NULL on error, otherwise returns a pointer to a header struct.
 */
struct pktgen_hdr *nf_gen_extract_header(struct nf_cap_t *, const uint8_t *, int);
/** @} */

void nf_cap_add_rule(int, uint8_t, uint32_t, uint32_t, uint16_t, uint8_t, 
		uint32_t, uint32_t, uint16_t);
void nf_cap_clear_rule(int);
void nf_cap_clear_rules();

#endif
